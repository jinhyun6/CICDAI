from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.services.user_service import UserService
from app.api.github import get_user_id_from_token
from app.services.github_service import GitHubService
import httpx
import base64
from typing import Dict, List
import json

router = APIRouter()

@router.post("/check-existing-files")
async def check_existing_files(
    data: Dict,
    user_id: int = Depends(get_user_id_from_token),
    db: AsyncSession = Depends(get_db)
):
    """커밋하기 전에 기존 파일 확인"""
    repo_full_name = data.get("repo_full_name")
    files_to_check = data.get("files", [])
    
    # GitHub 토큰 가져오기
    user_service = UserService(db)
    tokens = await user_service.get_user_tokens(user_id)
    github_token = tokens.get("github_token")
    
    if not github_token:
        raise HTTPException(status_code=400, detail="GitHub 연결이 필요합니다")
    
    github_service = GitHubService(github_token)
    repo = github_service.get_repo(repo_full_name)
    
    existing_files = []
    for file_path in files_to_check:
        try:
            repo.get_contents(file_path)
            existing_files.append(file_path)
        except:
            pass
    
    return {
        "existing_files": existing_files,
        "has_conflicts": len(existing_files) > 0
    }

@router.post("/commit-cicd-files")
async def commit_cicd_files(
    data: Dict,
    user_id: int = Depends(get_user_id_from_token),
    db: AsyncSession = Depends(get_db)
):
    """AI가 생성한 파일들을 GitHub 저장소에 커밋"""
    repo_full_name = data.get("repo_full_name")
    generated_files = data.get("generated_files", {})
    force_overwrite = data.get("force_overwrite", False)
    
    if not repo_full_name or not generated_files:
        raise HTTPException(status_code=400, detail="Repository name and files required")
    
    # GitHub 토큰 가져오기
    user_service = UserService(db)
    tokens = await user_service.get_user_tokens(user_id)
    github_token = tokens.get("github_token")
    
    if not github_token:
        raise HTTPException(status_code=400, detail="GitHub 연결이 필요합니다")
    
    github_service = GitHubService(github_token)
    
    commits_made = []
    errors = []
    
    try:
        # 1. Dockerfile(s) 커밋
        dockerfiles = generated_files.get("dockerfiles", [])
        for dockerfile in dockerfiles:
            path = dockerfile.get("path", "Dockerfile")
            content = dockerfile.get("content", "")
            
            if content:
                # 파일이 이미 존재하는지 먼저 확인
                file_exists = False
                try:
                    repo = github_service.get_repo(repo_full_name)
                    repo.get_contents(path)
                    file_exists = True
                except:
                    pass
                
                # 파일이 존재하고 force_overwrite가 False면 다른 이름으로 저장
                if file_exists and not force_overwrite:
                    # 백업 파일명 생성 (예: Dockerfile.ai-generated)
                    path = f"{path}.ai-generated"
                    message = f"Add AI-generated {path} (original exists)"
                else:
                    message = f"{'Update' if file_exists else 'Add'} {path} generated by CI/CD AI"
                
                print(f"Committing Dockerfile to {path}")
                result = await github_service.create_or_update_file(
                    repo_full_name=repo_full_name,
                    path=path,
                    content=content,
                    message=message
                )
                commits_made.append({
                    "type": "dockerfile",
                    "path": path,
                    "sha": result.get("commit", {}).get("sha")
                })
        
        # 2. GitHub Actions Workflow 커밋
        workflow = generated_files.get("workflow", {})
        if workflow.get("content"):
            workflow_path = workflow.get("path", ".github/workflows/deploy.yml")
            
            # 파일이 이미 존재하는지 확인
            file_exists = False
            try:
                repo = github_service.get_repo(repo_full_name)
                repo.get_contents(workflow_path)
                file_exists = True
            except:
                pass
            
            # 파일이 존재하고 force_overwrite가 False면 다른 이름으로 저장
            if file_exists and not force_overwrite:
                # 다른 워크플로우 이름 생성 (예: deploy-ai.yml)
                workflow_path = workflow_path.replace("deploy.yml", "deploy-ai.yml")
                message = "Add AI-generated workflow (original exists)"
            else:
                message = f"{'Update' if file_exists else 'Add'} GitHub Actions workflow for CI/CD"
            
            print(f"Committing workflow to {workflow_path}")
            result = await github_service.create_or_update_file(
                repo_full_name=repo_full_name,
                path=workflow_path,
                content=workflow.get("content"),
                message=message
            )
            commits_made.append({
                "type": "workflow",
                "path": workflow_path,
                "sha": result.get("commit", {}).get("sha")
            })
        
        # 3. 환경변수 문서화 (README 업데이트 또는 .env.example 생성)
        env_vars = generated_files.get("environment_variables", [])
        if env_vars:
            env_example_content = "# Environment variables required for deployment\n\n"
            for env in env_vars:
                env_example_content += f"# {env.get('description', '')}\n"
                env_example_content += f"{env.get('name')}=\n\n"
            
            result = await github_service.create_or_update_file(
                repo_full_name=repo_full_name,
                path=".env.example",
                content=env_example_content,
                message="Add environment variables documentation"
            )
            commits_made.append({
                "type": "env_example",
                "path": ".env.example",
                "sha": result.get("commit", {}).get("sha")
            })
        
        return {
            "success": True,
            "commits": commits_made,
            "message": f"Successfully committed {len(commits_made)} files",
            "next_steps": {
                "setup_secrets": True,
                "trigger_workflow": True,
                "workflow_url": f"https://github.com/{repo_full_name}/actions"
            }
        }
        
    except Exception as e:
        print(f"Error committing files: {str(e)}")
        return {
            "success": False,
            "commits": commits_made,
            "errors": [str(e)],
            "message": f"Partially completed. {len(commits_made)} files committed."
        }

@router.post("/setup-github-secrets")
async def setup_github_secrets(
    data: Dict,
    user_id: int = Depends(get_user_id_from_token),
    db: AsyncSession = Depends(get_db)
):
    """GitHub Secrets 설정 (GCP 서비스 계정 키 등)"""
    repo_full_name = data.get("repo_full_name")
    gcp_project_id = data.get("gcp_project_id")
    service_name = data.get("service_name")
    region = data.get("region", "us-central1")
    
    if not repo_full_name:
        raise HTTPException(status_code=400, detail="Repository name required")
    
    # GitHub 토큰 가져오기
    user_service = UserService(db)
    tokens = await user_service.get_user_tokens(user_id)
    github_token = tokens.get("github_token")
    
    if not github_token:
        raise HTTPException(status_code=400, detail="GitHub 연결이 필요합니다")
    
    github_service = GitHubService(github_token)
    
    secrets_created = []
    
    try:
        # 필수 Secrets 설정
        required_secrets = {
            "GCP_PROJECT_ID": gcp_project_id,
            "GCP_SERVICE_NAME": service_name,
            "GCP_REGION": region,
            # GCP_SA_KEY는 별도로 처리 필요 (서비스 계정 생성 후)
        }
        
        for secret_name, secret_value in required_secrets.items():
            if secret_value:
                await github_service.create_or_update_secret(
                    repo_full_name=repo_full_name,
                    secret_name=secret_name,
                    secret_value=secret_value
                )
                secrets_created.append(secret_name)
        
        return {
            "success": True,
            "secrets_created": secrets_created,
            "message": f"Created {len(secrets_created)} secrets",
            "missing_secrets": ["GCP_SA_KEY"],
            "next_step": "Create GCP service account and add GCP_SA_KEY secret"
        }
        
    except Exception as e:
        print(f"Error setting up secrets: {str(e)}")
        return {
            "success": False,
            "secrets_created": secrets_created,
            "error": str(e)
        }

@router.post("/trigger-workflow")
async def trigger_workflow(
    data: Dict,
    user_id: int = Depends(get_user_id_from_token),
    db: AsyncSession = Depends(get_db)
):
    """GitHub Actions 워크플로우 수동 트리거"""
    repo_full_name = data.get("repo_full_name")
    workflow_file = data.get("workflow_file", "deploy.yml")
    branch = data.get("branch", "main")
    
    if not repo_full_name:
        raise HTTPException(status_code=400, detail="Repository name required")
    
    # GitHub 토큰 가져오기
    user_service = UserService(db)
    tokens = await user_service.get_user_tokens(user_id)
    github_token = tokens.get("github_token")
    
    if not github_token:
        raise HTTPException(status_code=400, detail="GitHub 연결이 필요합니다")
    
    # GitHub API를 사용해 워크플로우 트리거
    async with httpx.AsyncClient() as client:
        # workflow_dispatch 이벤트 생성
        response = await client.post(
            f"https://api.github.com/repos/{repo_full_name}/actions/workflows/{workflow_file}/dispatches",
            headers={
                "Authorization": f"token {github_token}",
                "Accept": "application/vnd.github.v3+json"
            },
            json={
                "ref": branch,
                "inputs": {}
            }
        )
        
        if response.status_code == 204:
            return {
                "success": True,
                "message": "Workflow triggered successfully",
                "workflow_url": f"https://github.com/{repo_full_name}/actions"
            }
        else:
            return {
                "success": False,
                "error": f"Failed to trigger workflow: {response.status_code}",
                "details": response.text
            }